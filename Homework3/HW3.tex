\documentclass[11pt]{exam}
\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{float}
\usepackage{forest}
\usepackage[colorlinks,linkcolor=blue]{hyperref}

% in order to compile this file you need to get 'header.tex' from
% Canvas and change the line below to the appropriate file path
\input{header}

\geometry{left=2.5 cm,right=2.5 cm,top=2.5 cm,bottom=2.5 cm}
%\pagestyle{fancy}
\definecolor{mygreen}{rgb}{0,0.6,0}  
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82} 
\definecolor{background}{rgb}{0.963,0.963,0.963}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\newcommand{\hwnum}{3}
\newcommand{\duedate}{11:59pm, July 8th}

%\notesheader
\hwheader   % header for homework
%\hwslnheader   % header for homework solutions

% Comment the following line in order to hide solutions.
% Uncomment the line to show solutions written inside of
% LaTeX solution environments like:
%   \begin{solution}
%     My solution.
%   \end{solution}.
\printanswers

\begin{document}
\setlength{\parindent}{0pt}
\section*{Before you start:}

\subsection*{Homework Files}
You can download the starter files for coding as well as this \textit{tex} file (you only need to modify \textit{homework3.tex}) on canvas and do your homework with latex. Or you can scan your handwriting, convert to pdf file, and upload it to canvas before the due date. If you choose to write down your answers by hand, you can directly download the pdf file on canvas which provides more blank space for solution box.\\

\subsection*{Submission Form}
A pdf file as your solution named as VE281\_HW3\_[Your Student ID]\_[Your name].pdf uploaded to canvas


Estimated time used for this homework: \textbf{3-4 hours.}
\\\\


\newpage
\section*{0\quad Student Info}
Your name and student id:
\begin{solution}
    % Write your answer here
    Wang Zi Ning 520370910042
\end{solution}

\section{Tree Traversal (26 points)}

\subsection{Given A Tree (16 points)}
Given a binary tree below, please write out the following traversals:
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\linewidth]{binary_tree.png}
\end{figure}
\begin{enumerate}[(a)]
    \item Pre-order depth-first traversal. (4 points)
          \begin{solution}
              %Write your answer here.
              A$\to$B$\to$D$\to$H$\to$E$\to$I$\to$M$\to$J$\to$C$\to$F$\to$G$\to$K$\to$N$\to$L
          \end{solution}

    \item Post-order depth-first traversal. (4 points)
          \begin{solution}
              %Write your answer here.
              H$\to$D$\to$M$\to$I$\to$J$\to$E$\to$B$\to$F$\to$N$\to$K$\to$L$\to$G$\to$C$\to$A
          \end{solution}

    \item In-order depth-first traversal. (4 points)
          \begin{solution}
              %Write your answer here.
              H$\to$D$\to$B$\to$I$\to$M$\to$E$\to$J$\to$A$\to$F$\to$C$\to$N$\to$K$\to$G$\to$L
          \end{solution}

    \item Level-order traversal. (4 points)
          \begin{solution}
              %Write your answer here.
              A$\to$B$\to$C$\to$D$\to$E$\to$F$\to$G$\to$H$\to$I$\to$J$\to$K$\to$L$\to$M$\to$N
          \end{solution}

\end{enumerate}


\subsection{Draw The Tree (10 points)}
\begin{enumerate}[a)]
    \item Now we have a specific binary tree, but we only know some of its traversals. Its pre-order traversal is: \textbf{GCABFEDIHKJ}, and its in-order traversal is: \textbf{ABCDEFGHIJK}. Then please \textbf{draw out the binary tree} and show its \textbf{post-order traversal}. (4 points)

          \begin{solution}
              % Write your answer here
              \begin{forest}
                  for tree={circle,draw}
                  [G
                      [C
                              [A
                                      [,phantom]
                                      [B]
                              ]
                              [F
                                      [E
                                              [D]
                                              [,phantom]
                                      ]
                                      [,phantom]
                              ]
                      ]
                      [I
                              [H]
                              [K
                                      [J]
                                      [,phantom]
                              ]
                      ]
                  ]
              \end{forest}

              B$\to$A$\to$D$\to$E$\to$F$\to$C$\to$H$\to$J$\to$K$\to$I$\to$G
          \end{solution}

    \item Now we have a specific binary tree, but we only know some of its traversals. Its post-order traversal is: \textbf{BDCAGIKJHFE}, and its in-order traversal is: \textbf{ABCDEFGHIJK}. Then please \textbf{draw out the binary tree} and show its \textbf{pre-order traversal}. (4 points)

          \begin{solution}
              % Write your answer here
              \begin{forest}
                  for tree={circle,draw}
                  [E
                      [A
                              [,phantom]
                              [C
                                      [B]
                                      [D]
                              ]
                      ]
                      [F
                              [,phantom]
                              [H
                                      [G]
                                      [J
                                              [I]
                                              [K]
                                      ]
                              ]
                      ]
                  ]
              \end{forest}

              E$\to$A$\to$C$\to$B$\to$D$\to$F$\to$H$\to$G$\to$J$\to$I$\to$K
          \end{solution}

    \item After finishing the previous two questions, our smart Mr. Blue Tiger decides to publish paper title \textbf {New discovery!! Any pair of 2 distinctive DFS sequences has one and only one corresponding binary tree.} (distinctive here means following different order of DFS)
          However, our strong TAA Chengyu does not seem to agree with Mr. Blue Tiger. He decides to publish another paper to explain why Mr. Blue Tiger's statement is wrong. Could you briefly explain the reasons? A more detailed statement should be made. (Hint: This problem is related to different combinations of distinctive DFS sequences, i.e. which two out of three orders are picked as known sequences)

          \begin{solution}
              % Write your answer here
              When we get pre-order and post-order, the tree may not be unique because the node with one leaf will have same pre-order and post-order travel no matter the leaf is on the left or on the right.

              For example , both
              \begin{forest}
                  for tree={circle,draw}
                  [A
                      [B]
                      [,phantom]
                  ]
              \end{forest}
              and
              \begin{forest}
                  for tree={circle,draw}
                  [A
                      [,phantom]
                      [B]
                  ]
              \end{forest} have same pre-order and post-order travel.

              If the in-order travel is known and either pre-order or post-order travel is known, we have one and only one corresponding binary tree.
          \end{solution}

\end{enumerate}

\section{Heap (23 points)}
Consider a min-heap represented by the following array:
\begin{align*}
    \{18,25,32,77,86,35,93,80\}
\end{align*}

Perform the following operations using the algorithms for binary heaps discussed in lecture. Ensure that the heap property is restored at the end of every individual operation.

For the following operations, please briefly describe what and how you use the given functions: \textbf{percolateUp()} and \textbf{percolateDown()}, and show the result of the heap after each operation in either tree form or array form.

\begin{enumerate}[a)]
    \item Push the value of 20 into this min-heap. (4 points)
          \begin{solution}
              % Write your answer here
              Draw the heap in the form of tree and we can get\[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [25
                                  [77
                                          [80]
                                          [,phantom]][86]]
                          [32[35][93]]
                      ]
                  \end{forest}.\]
              Then push 20 into the heap and we get\[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [25
                                  [77
                                          [80]
                                          [20]][86]]
                          [32[35][93]]
                      ]
                  \end{forest}.\]
              Apply \textbf{percolateUp(9)} we can get\[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [25
                                  [20
                                          [80]
                                          [77]][86]]
                          [32[35][93]]
                      ]
                  \end{forest}\] and then\[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][86]]
                          [32[35][93]]
                      ]
                  \end{forest}.\]
          \end{solution}

    \item Push the value of 11 into this min-heap. (4 points)
          \begin{solution}
              % Write your answer here
              We have \[ \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][86[11][,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}.\]
              Apply \textbf{percolateUp(10)} and we can get \[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][11[86][,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}\]
              ans then \[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [11
                                  [25
                                          [80]
                                          [77]][20[86][,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}\]
              and finally \[
                  \begin{forest}
                      for tree={circle,draw}
                      [11
                          [18
                                  [25
                                          [80]
                                          [77]][20[86][,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}\]
          \end{solution}

    \item Remove the min element from the heap. (5 points)
          \begin{solution}
              % Write your answer here
              We have \[ \begin{forest}
                      for tree={circle,draw}
                      [86
                          [18
                                  [25
                                          [80]
                                          [77]][20[11][,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest} \]
              and then remove the last node, getting \[
                  \begin{forest}
                      for tree={circle,draw}
                      [86
                          [18
                                  [25
                                          [80]
                                          [77]][20]]
                          [32[35][93]]
                      ]
                  \end{forest}. \]
              Apply \textbf{percolateDown(1)} we can get \[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [86
                                  [25
                                          [80]
                                          [77]][20]]
                          [32[35][93]]
                      ]
                  \end{forest} \] and then \[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][86]]
                          [32[35][93]]
                      ]
                  \end{forest}. \]
          \end{solution}

    \item Push the value of 79 into this min-heap. (4 points)
          \begin{solution}
              % Write your answer here
              We have \[ \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][86 [79] [,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}  \]after pushing.

              Then apply \textbf{percolateUp(10)} we can get \[
                  \begin{forest}
                      for tree={circle,draw}
                      [18
                          [20
                                  [25
                                          [80]
                                          [77]][79 [86] [,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest}. \]
          \end{solution}

    \item Remove the min element from the heap. (5 points)
          \begin{solution}
              % Write your answer here
              We have  \[
                  \begin{forest}
                      for tree={circle,draw}
                      [86
                          [20
                                  [25
                                          [80]
                                          [77]][79 [18] [,phantom]]]
                          [32[35][93]]
                      ]
                  \end{forest} \] and then remove the last node, getting
              \[
                  \begin{forest}
                      for tree={circle,draw}
                      [86
                          [20
                                  [25
                                          [80]
                                          [77]][79 ]]
                          [32[35][93]]
                      ]
                  \end{forest}. \]
              Apply  \textbf{percolateDown(1)}, we have
              \[ \begin{forest}
                      for tree={circle,draw}
                      [20
                          [86
                                  [25
                                          [80]
                                          [77]][79 ]]
                          [32[35][93]]
                      ]
                  \end{forest} \] and then  \[
                  \begin{forest}
                      for tree={circle,draw}
                      [20
                          [25
                                  [86
                                          [80]
                                          [77]][79 ]]
                          [32[35][93]]
                      ]
                  \end{forest} \]
              and finally we can get  \[
                  \begin{forest}
                      for tree={circle,draw}
                      [20
                          [25
                                  [77
                                          [80]
                                          [86]][79 ]]
                          [32[35][93]]
                      ]
                  \end{forest}.  \]
          \end{solution}

\end{enumerate}

\section{BST Basics (26 points)}
\subsection{Simple Simulation (10 points)}
Perform the following operations to construct a binary search tree. Show the result of the BST after each operation in either tree form or array form.
\begin{enumerate}[i)]
    \item Insert 24, 29, 22, 25, 19, 32, 15, 37 (2 points)
          \begin{solution}
              % Write your answer here
              We have\begin{forest}
                  for tree={circle,draw}
                  [24
                      [22
                              [19
                                      [15]
                                      [,phantom]][,phantom]]
                      [29[25][32[,phantom][37]]]
                  ]
              \end{forest}.
          \end{solution}

    \item Delete 22 (3 points)
          \begin{solution}
              % Write your answer here
              We have\begin{forest}
                  for tree={circle,draw}
                  [24
                      [19
                              [15
                              ][,phantom]]
                      [29[25][32[,phantom][37]]]
                  ]
              \end{forest}.
          \end{solution}

    \item Delete 29 (3 points)
          \begin{solution}
              % Write your answer here 
              We have\begin{forest}
                  for tree={circle,draw}
                  [24
                      [19
                              [15
                              ][,phantom]]
                      [25[,phantom][32[,phantom][37]]]
                  ]
              \end{forest}.
          \end{solution}

    \item Insert 22 (2 points)
          \begin{solution}
              % Write your answer here
              We have\begin{forest}
                  for tree={circle,draw}
                  [24
                      [19
                              [15
                              ][22]]
                      [25[,phantom][32[,phantom][37]]]
                  ]
              \end{forest}.
          \end{solution}
\end{enumerate}

\subsection{Basic Questions (16 points)}
Please finish the multiple choice questions below, no explanation is needed.
\begin{enumerate}[i)]
    \item The following numbers are inserted into an empty binary search tree in the given order: 10, 1, 3, 5, 15, 12, 16. What is the \textbf{height} of the binary search tree? (4 points)
          \begin{enumerate}[A.]
              \item 2
              \item 3
              \item 4
              \item 5
          \end{enumerate}

          \begin{solution}
              % Write your answer here
              B
          \end{solution}

    \item Suppose we want to delete a node with its left and right child as non-empty in a binary search tree, we may need to find the largest element in its left subtree (inorder predecessor) or the smallest element in its right subtree (inorder successor). Which of the following is \textbf{true} about the inorder successor? (4 points)
          \begin{enumerate}[A.]
              \item Inorder successor is always a leaf node.
              \item Inorder success is always either a left node or a node with empty left child.
              \item Inorder successor may be an ancestor of the node.
              \item Inorder successor is always either a leaf node or a node with empty right child.
          \end{enumerate}

          \begin{solution}
              % Write your answer here
              B
          \end{solution}

    \item A binary search tree is used to locate the number 43. Which one of the following probe sequence is \textbf{not possible}? (4 points)
          \begin{enumerate}[A.]
              \item 61, 52, 14, 17, 40, 43
              \item 10, 65, 31, 48, 37, 43
              \item 81, 61, 52, 14, 41, 43
              \item 17, 77, 27, 66, 18, 43
          \end{enumerate}

          \begin{solution}
              % Write your answer here
              D
          \end{solution}

    \item Consider the following statements:
          \begin{enumerate}[I.]
              \item The smallest element in a max-heap is always at a leaf node.
              \item The second largest element in a max-heap is always a child of the root node.
              \item A max-heap can be constructed from a binary search tree in $\Theta(n)$ time.
              \item A binary search tree can be constructed from a max-heap in $\Theta(n)$ time.
          \end{enumerate}
          Which of the above statements are \textbf{true}? (4 points)
          \begin{enumerate}[A.]
              \item I, II and III
              \item I, II and IV
              \item I, III and IV
              \item I, II, III, and IV
          \end{enumerate}

          \begin{solution}
              % Write your answer here
              D
          \end{solution}
\end{enumerate}

\section{Binary Search Tree Analysis (12 points)}
\subsection{BST Better than List? (4 points)}
After learning binary search tree, Ssy thinks that BST can perform much better than list. As he is still trying to finish project2, he immediately thinks of an idea to combine hash table with BST. In separate chaining strategy, he uses binary search tree instead of list inside each bucket. Do you think there are any \textbf{advantages or disadvantages} of this strategy? Briefly explain your idea.

\begin{solution}
    % Write your answer here
    In a hash table, the chain in each bucket should not be quite long, so the advantage of BST in searching will not be a lot.

    However, the delete operation of BST is more complex than that of list.

    So if the hash table will have many delete operation, using BST may have disadvantage on time. If there will be many node in one bucket, using BST will have advantage on time.

    In each node, BST will need more space to store two child node while list only need to store one child. So using BST will have disadvantage on memory usage.
\end{solution}

\subsection{Simple Application (8 points)}
Suppose now you're going to implement an algorithm which accepts a root node of a binary search tree and two values. These two values are known to present in the BST. The algorithm will print the value of a node which is the least common ancestor of these 2 elements. Please finish the algorithm below.

Note: A node $X$ is said to be the common ancestor of node $A$ and $B$ means both $A$ and $B$ are in the subtree (either left or right) of $X$. A least common ancestor is a common ancestor such that all other common ancectors are its ancestors.
\begin{lstlisting}[language=c++]
void Find_LCA (Node *root, int a, int b) {
    while (root != null) {
        if( /*write your code here*/ ) {
            root = root->left;
        }
        else if( /*write your code here*/ ) {
            root = root->right;
        }
        else {
            break;
        }
    }
    std::cout << root->value << std::endl; 
}
\end{lstlisting}

\begin{solution}
    % Write your answer here
    \begin{lstlisting}[language=c++]
        void Find_LCA (Node *root, int a, int b) {
            while (root != null) {
                if( (a<(root->value)) && (b<(root->value))  ) {
                    root = root->left;
                }
                else if(  (a>(root->value)) && (b>(root->value)) ) {
                    root = root->right;
                }
                else {
                    break;
                }
            }
            std::cout << root->value << std::endl; 
        }
        \end{lstlisting}\end{solution}


\newpage
\section{BST Interesting Questions (13 points)}
\subsection{Perfect Balance (8 points)}
Propose an algorithm which inserts a set of keys into an initially empty binary search tree such that the tree produced is equivalent to binary search. This means the sequence of compares done in find() is the \textbf{same} as the sequence of compares used by binary search for the same key. Also analyze time complexity of this algorithm.

Hint: In binary search, we first compare current key with $\frac{n}{2}$th key in the array, then compare current key with $\frac{n}{4}$th key or $\frac{3n}{4}$th key in the array, etc.

\begin{solution}
    % Write your answer here

    Define a help function $fun$ that could make the tree from a sorted array.

    Then set the $\frac{n}{2}$th elements as the root element.

    Apply $fun$ on the array before the root elements (if exist) as the left subtree.

    Apply $fun$ on the array after the root elements (if exist) as the right subtree.

    The algorithm needs two step.

    First, sort the set into an array.

    Then, apply $fun$ on the array.

    The time complexity is $O(n \log n)$.

    Proof of that there will no algorithm better than $O(n \log n)$:

    If it exists with time complexity $O_x<O(n \log n)$, we can define a sorting algorithm by first generate a tree and then apply level travel order, putting value at the corresponding place.

    The time complexity is $O(n)+O_x<O(n)+O(n \log n) = O(n \log n)$.

    So we have an algorithm that have better time complexity than $O(n \log n)$.

    The keys only needs to allow comparing operation. So we get a algorithm that have better time performance than $O(n \log n)$ that only need comparison.

    That result contrast to the rules that the best time complexity for comparison sorting is $O(n \log n)$.

    So there will not exist that kind of algorithm.

\end{solution}

\subsection{BST with Duplicate keys (5 points)}
The binary search tree we introduced in the class does not support duplicate keys. By some modifications, we can make BST support duplicate keys. A simple approach is to change the rule of BST: the key smaller or equal to the current key goes to the left subtree, the key greater than the current key goes to the right subtree. However, a better solution is to add an additional field to each node called $count$, which is the number of current key in the binary search tree. Briefly introduce how to implement \textbf{insert} and \textbf{remove} in this kind of BST and explain why this approach is better than the first one.

\begin{solution}
    % Write your answer here

    In \textbf{insert}, we use same strategy if the to-insert value not equal to the node value. The inserted node have $count=1$.

    If they equal, just add $count$ by 1.

    In \textbf{remove}, we use same strategy if the node have $count==1$.

    If $count>1$, we just minus $count$ by 1.

\end{solution}
\end{document}